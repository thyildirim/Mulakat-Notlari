# Process ve Thread 
--------------------------------
Process --> Bellekte Ã§alÄ±ÅŸan baÄŸÄ±msÄ±z program
Thread ---> Bir processin iÃ§inde Ã§alÄ±ÅŸan daha kÃ¼Ã§Ã¼k yÃ¼rÃ¼tme birimi

Processler birbirinden izole Ã§alÄ±ÅŸÄ±rken, threadler aynÄ± ortamÄ± paylaÅŸÄ±r

Process: UygulamanÄ±n kendisi bir processâ€™tir.
Thread 1: ÅarkÄ± Ã§alma iÅŸini yapar.
Thread 2: KullanÄ±cÄ± arayÃ¼zÃ¼nÃ¼ yÃ¶netir.
Thread 3: Ä°nternetten mÃ¼zik indirir.


# Deadlock nedir ??
-------------------------------------
Deadlock, iÅŸlemlerin birbirinin kaynaklarÄ±nÄ± bekleyip sonsuza kadar kilitlenmesi durumudur.

ğŸ”‘ Deadlockâ€™un 4 Temel KoÅŸulu (Coffman KoÅŸullarÄ±)

Deadlock ancak aÅŸaÄŸÄ±daki 4 koÅŸul aynÄ± anda varsa gerÃ§ekleÅŸir:

    Mutual Exclusion (KarÅŸÄ±lÄ±klÄ± DÄ±ÅŸlama): Kaynaklar paylaÅŸÄ±lamaz, bir anda sadece bir iÅŸlem kullanabilir.

    Hold and Wait (Bekleyerek Tutma): Bir iÅŸlem kaynak tutarken baÅŸka kaynak iÃ§in bekler.

    No Preemption (Zorla AlÄ±namama): Kaynaklar zorla alÄ±namaz, ancak iÅŸlem kendi bÄ±rakabilir.

    Circular Wait (Dairesel Bekleme): Ä°ÅŸlemler birbirlerinin kaynaklarÄ±nÄ± dÃ¶ngÃ¼sel olarak bekler.


âš™ï¸ Pratikte Deadlock Ã–nleme YÃ¶ntemleri:

    Timeout (Zaman AÅŸÄ±mÄ±): Kaynak bekleme sÃ¼resi sÄ±nÄ±rlanÄ±r, sÃ¼resi dolunca iÅŸlem iptal edilir.

    Deadlock Detection (Tespit) ve Recovery (Kurtarma): Sistem deadlock oluÅŸtuÄŸunu algÄ±lar, sonra bazÄ± iÅŸlemleri sonlandÄ±rÄ±r veya kaynaklarÄ± zorla alÄ±r.

    Avoidance Algorithms (KaÃ§Ä±nma AlgoritmalarÄ±): Bankerâ€™s Algorithm gibi algoritmalar, kaynak isteklerini deÄŸerlendirip, deadlockâ€™a sebep olacak iÅŸlemleri reddeder.

    Lock Ordering (Kilitleme SÄ±rasÄ±): Kaynaklar belirli bir sÄ±rayla kilitlenir, bÃ¶ylece dÃ¶ngÃ¼sel bekleme olmaz.



# Scheduling (Zamanlama) algoritmalarÄ±
-----------------------------------------------------------

1. FCFS (First Come First Serve) â€“ Ä°lk Gelen Ä°lk Ä°ÅŸlenir

    Ä°ÅŸler sÄ±rayla, gelen sÄ±ra ile yapÄ±lÄ±r.

    Kim Ã¶nce gelirse Ã¶nce o iÅŸlem yapÄ±lÄ±r.

    Basit ama bekleme sÃ¼resi uzun olabilir.

2. SJF (Shortest Job First) â€“ En KÄ±sa Ä°ÅŸ Ã–ncelikli

    En kÄ±sa sÃ¼recek iÅŸlem Ã¶nce yapÄ±lÄ±r.

    Bekleme sÃ¼resini azaltÄ±r ama uzun iÅŸleri bekletebilir.

3. Round Robin (RR) â€“ SÄ±rasÄ±yla Her Ä°ÅŸe KÄ±sa SÃ¼re Verilir

    Ä°ÅŸlere sÄ±rayla kÃ¼Ã§Ã¼k zaman dilimleri (time quantum) verilir.

    SÃ¼re bitince sÄ±radaki iÅŸ devam eder.

    Adil ve interaktif sistemler iÃ§in uygun.

4. Priority Scheduling â€“ Ã–nceliklere GÃ¶re Ä°ÅŸlem

    Ä°ÅŸlere Ã¶ncelik verilir.

    Ã–nceliÄŸi yÃ¼ksek olan Ã¶nce yapÄ±lÄ±r.

    AynÄ± Ã¶ncelikte olanlar FCFSâ€™ye gÃ¶re sÄ±ralanÄ±r.

5. Multilevel Queue â€“ Ã‡ok KatmanlÄ± Kuyruk

    Ä°ÅŸler Ã¶ncelik veya tÃ¼rÃ¼ne gÃ¶re farklÄ± kuyruklara ayrÄ±lÄ±r.

    Kuyruklar farklÄ± zamanlama algoritmalarÄ± kullanabilir.


# Context switching
----------------------------------
Ä°ÅŸletim sisteminde bir iÅŸlemden diÄŸerine geÃ§erken eski iÅŸlemin durumunu kaydedip yeni iÅŸlemin durumunun yÃ¼klenmesidir.

Bir iÅŸlemci aynÄ± anda yalnÄ±zca bir iÅŸlem/thread Ã§alÄ±ÅŸtÄ±rabilir (tek Ã§ekirdekli bir sistemde). Ancak birden Ã§ok program Ã§alÄ±ÅŸtÄ±rÄ±lmak istendiÄŸinde iÅŸletim sistemi:

    Mevcut iÅŸlemi duraklatÄ±r (kaldÄ±ÄŸÄ± yeri unutmamak iÃ§in baÄŸlamÄ±nÄ± kaydeder),

    Yeni iÅŸlemin baÄŸlamÄ±nÄ± yÃ¼kler (o iÅŸlem kaldÄ±ÄŸÄ± yerden devam eder).

Bu geÃ§iÅŸe Context Switching denir.


# Sanal Bellek
------------------------------------
fiziksel belleÄŸin(ram) yetmediÄŸi durumda sabit diskin geÃ§ici ram gÃ¶revi gÃ¶rmesidir

ğŸ“¦ NasÄ±l Ã‡alÄ±ÅŸÄ±r?
Ä°ÅŸlem RAM'de yer kalmadÄ±ÄŸÄ±nda,
Az kullanÄ±lan veya ÅŸu an aktif olmayan veriler disk Ã¼zerinde ayrÄ±lmÄ±ÅŸ "pagefile" veya "swap" alanÄ±na" taÅŸÄ±nÄ±r.
Bu alan, RAM gibi davranÄ±r ama daha yavaÅŸtÄ±r.
