# Array
--------------------------------
Sabit boyutlu (statik) veya dinamik olabilir.
Rastgele eriÅŸim (random access) saÄŸlar.
Bellekte ardÄ±ÅŸÄ±k yer kaplar.


EriÅŸim (Access)	O(1)
Arama (Search)	O(n)
Ekleme (Insert)	O(n)
Silme (Delete)	O(n)




# Stack 
---------------------------
    Ã‡alÄ±ÅŸma mantÄ±ÄŸÄ±: LIFO â€“ Last In, First Out (Son giren ilk Ã§Ä±kar)

    Ä°ÅŸlemler:

        push() â†’ Eleman ekleme

        pop() â†’ Eleman Ã§Ä±karma

        peek() â†’ En Ã¼stteki elemana bakma


Push	O(1)
Pop	O(1)
Peek	O(1)
Arama	O(n)



# Queue
-------------------------
    Ã‡alÄ±ÅŸma mantÄ±ÄŸÄ±: FIFO â€“ First In, First Out (Ä°lk giren ilk Ã§Ä±kar)

    Ä°ÅŸlemler:

        enqueue() â†’ Eleman ekleme

        dequeue() â†’ Eleman Ã§Ä±karma

        peek() â†’ En Ã¶ndeki elemana bakma


# Linked List
----------------------------
    Linked List, dÃ¼ÄŸÃ¼mlerden (node) oluÅŸur. 
    Her dÃ¼ÄŸÃ¼m hem veriyi hem de bir sonraki dÃ¼ÄŸÃ¼mÃ¼n adresini (pointer) tutar.

TÃ¼rleri:

    Singly Linked List: Sadece ileriye doÄŸru baÄŸlantÄ±.

    Doubly Linked List: Hem ileri hem geri baÄŸlantÄ±.

    Circular Linked List: Son dÃ¼ÄŸÃ¼m ilk dÃ¼ÄŸÃ¼me iÅŸaret eder.

AvantajlarÄ±:

    Dinamik bellek kullanÄ±mÄ± â†’ BelleÄŸi verimli kullanÄ±r.

    Eleman ekleme/Ã§Ä±karma iÅŸlemleri hÄ±zlÄ±dÄ±r (Ã¶zellikle dizinin baÅŸÄ±nda/ortasÄ±nda).

    Boyutu deÄŸiÅŸtirilebilir.

DezavantajlarÄ±:

    Rastgele eriÅŸim yoktur (index ile eriÅŸmek zor).

    Bellek kullanÄ±mÄ± dizilere gÃ¶re fazladÄ±r (Ã§Ã¼nkÃ¼ pointer da tutulur).


EriÅŸim	    O(n)	 --> Singly linked list big O Notasyonu
Arama	    O(n)	
BaÅŸa Ekleme	O(1)	
Sona Ekleme	O(n)	
Silme (baÅŸ/son)	O(1)/O(n)




# Binary Search Tree
--------------------------------
    Her dÃ¼ÄŸÃ¼mÃ¼n en fazla 2 Ã§ocuÄŸu vardÄ±r.

    Ekleme: Yeni deÄŸer, bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne gÃ¶re uygun yere yerleÅŸtirilir.

    Arama: DeÄŸer, kÃ¶kten baÅŸlayarak karÅŸÄ±laÅŸtÄ±rmalarla bulunur.

    Silme: 3 durum olabilir (yaprak, tek Ã§ocuk, 2 Ã§ocuk).

SÄ±ralama iÅŸlemleri iÃ§in ideal (in-order traversal â†’ sÄ±ralÄ± veri)

Ekleme	O(log n)	O(n)
Arama	O(log n)	O(n)
Silme	O(log n)	O(n)


# AVL Tree
------------------------------
Dengeli BST'dir her durumda O(log n) 



# Big O Notasyonu
----------------------------------
    AlgoritmanÄ±n verimliliÄŸi ve karmaÅŸÄ±klÄ±gÄ±nÄ± gÃ¶steren matematiksel deÄŸer





# Hash Table
--------------------------------------
Verileri anahtar-deÄŸer (key-value) ÅŸeklinde depolayan veri yapÄ±sÄ±.

Anahtar, bir hash fonksiyonu ile dizi indeksine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.

Hash Table	O(1)	O(1)	O(1) â€“ Ã‡akÄ±ÅŸma olursa O(n)

Ortalama durumda Ã§ok hÄ±zlÄ± (O(1))

En kÃ¶tÃ¼ durumda yavaÅŸ olabilir (O(n))

# Map
---------------------
Map, anahtar-deÄŸer (key-value) Ã§iftlerini saklayan bir soyut veri yapÄ±sÄ±dÄ±r.
Anahtar Ã¼zerinden deÄŸere ulaÅŸÄ±m hÄ±zlÄ±dÄ±r.
Map (HashMap)	O(1)	O(1)	O(1) (ortalama) (EKLEME SÄ°LME VE ARAMA NOTASYONU)


#Dictionary 
--------------------------
Pythonâ€™daki dict, Map'in bir uygulamasÄ±dÄ±r.

Anahtar-deÄŸer yapÄ±sÄ± kullanÄ±r.

HÄ±zlÄ± arama, ekleme ve silme iÅŸlemleri sunar.

Ekleme O(1)	
Silme O(1)	
Arama O(1)


# Set
---------------------
Tekil (unique) elemanlarÄ± saklar.
SÄ±ra Ã¶nemli deÄŸildir.

Duplicate filtreleme
KÃ¼me iÅŸlemleri (kesiÅŸim, birleÅŸim, fark)


# Graph
---------------------------
DÃ¼ÄŸÃ¼mler (nodes/vertices) ve baÄŸlantÄ±lar (edges) iÃ§erir.

YÃ¶nlÃ¼ veya yÃ¶nsÃ¼z olabilir.

AÄŸÄ±rlÄ±klÄ± veya aÄŸÄ±rlÄ±ksÄ±z olabilir.

Ä°ki temel gÃ¶sterim vardÄ±r:

    Adjacency List (Listeyle tutulur)

    Adjacency Matrix (2D matrisle tutulur)


# Heap
------------------------
Tam ikili aÄŸaÃ§tÄ±r (complete binary tree).

Her dÃ¼ÄŸÃ¼m, Ã§ocuklarÄ±ndan bÃ¼yÃ¼ktÃ¼r veya kÃ¼Ã§Ã¼ktÃ¼r.Genellikle Ã¶ncelik sÄ±rasÄ± (priority queue) iÃ§in kullanÄ±lÄ±r.
ğŸ¯ KullanÄ±m:

    CPU Scheduling

    KÄ±sÄ±tlÄ± en kÃ¼Ã§Ã¼k/en bÃ¼yÃ¼k deÄŸer bulma

    Dijkstra algoritmasÄ±